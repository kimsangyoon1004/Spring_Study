# 0장 - 스프링과 스프링부트 개요

---

## 1. 스프링(Spring)이란?

### 1.1 한 줄 정의

> **엔터프라이즈용 Java 애플리케이션 개발을 편하게 할 수 있게 해주는 오픈소스 경량급 애플리케이션 프레임워크**

쉽게 말하면, **기업용 웹 서비스를 만들 때 반복되는 귀찮은 일을 대신 해주는 Java 도구상자**라고 생각하면 된다.

---

### 1.2 비유로 이해하기

**자동차를 만든다고 생각해보자.**

- **프레임워크 없이**: 바퀴, 엔진, 차체, 내부장치를 전부 직접 설계·제작해야 함
- **스프링 사용**: 이미 만들어진 차체(뼈대)를 가져다 쓰고, 우리가 필요한 기능만 붙이면 됨

스프링은 **웹 애플리케이션의 뼈대**를 미리 만들어둔 것이다. 우리는 **비즈니스 로직**(주문하기, 결제하기 등)에만 집중하면 된다.

---

### 1.3 스프링의 역사와 탄생 배경

#### 스프링 이전: EJB 시대

2000년대 초반, **EJB(Enterprise Java Bean)**가 기업용 Java 개발의 표준이었다.

- **EJB의 아이디어**: "비즈니스 객체들을 컨테이너에서 관리하고, 필요할 때 꺼내 쓰자"
- **문제**: 컨테이너의 보안, 트랜잭션 등을 쓰려면 **EJB 스펙을 꼭 지켜야** 함

#### EJB의 한계

| 문제 | 설명 |
|------|------|
| **기술 침투** | 비즈니스 로직에 EJB 기술이 강하게 묶여 있음. EJB를 바꾸면 코드 전체를 고쳐야 함 |
| **코드 비대화** | 실제로 필요한 메서드는 3개인데, EJB 스펙을 지키려는 코드가 훨씬 더 많아짐 |
| **벤더 종속** | WebLogic, Jeus 등 벤더마다 구현이 달라서, 다른 서버로 옮기기 어려움 |
| **복잡한 설정** | 초기 설정이 너무 복잡함 |

**기술 침투**란, **내 비즈니스 로직이 특정 기술(EJB, 특정 DB 등)에 묶여 있어서, 그 기술을 바꾸면 코드를 전부 수정해야 하는 상태**를 말한다.

#### 스프링의 탄생

**로드 존슨(Rod Johnson)**이 2002년 저서 *Expert One-on-One J2EE Design and Development*에서 제시한 코드가 스프링의 시초다.

- **핵심 아이디어**: EJB 없이도 **객체 간 의존성을 해결**할 수 있는 컨테이너를 만들자
- **철학**: **기술 비침투** — 특정 기술에 묶이지 않고, 순수 Java 객체만으로 개발

즉, **비즈니스 로직에만 집중하고, 기술적인 부분은 스프링이 알아서 처리해준다**가 스프링의 **기본 철학**이다.

#### 버전 이력 (참고)

| 버전 | 연도 |
|------|------|
| 1.0 | 2004년 3월 |
| 2.0 | 2006년 10월 |
| 3.0 | 2009년 12월 |
| 4.0 | 2013년 12월 |
| 5.0 | 2017년 9월 |

---

### 1.4 정의를 단어별로 풀어보기

| 용어 | 의미 | 쉽게 말하면 |
|------|------|-------------|
| **엔터프라이즈용** | 기업에서 쓰는 대규모 웹 서비스 | 카카오, 네이버 같은 서비스 수준의 개발 |
| **오픈소스** | 소스코드가 공개되어 있고, 무료로 사용 가능 | SpringSource(VMware)가 관리해 안정적 |
| **경량급** | EJB 대비 코드가 단순하고 가벼움 | 불필요한 보일러플레이트 코드가 적음 |
| **애플리케이션 프레임워크** | 웹 개발에 필요한 여러 기술의 뼈대를 한 번에 제공 | DB, 보안, 웹, 트랜잭션 등 전반을 지원 |

---

## 2. 스프링의 핵심 특징

### 2.1 POJO (Plain Old Java Object)

#### POJO란?

**오래된 방식의 단순한 Java 객체** — 즉, **순수 Java만**으로 만든 객체다.

- **`extends`**로 특정 클래스를 상속받지 않음
- **`implements`**로 특정 인터페이스를 구현하지 않음 (비즈니스 목적 제외)
- **외부 라이브러리·프레임워크에 의존하지 않음**

#### 왜 중요한가?

```
[POJO가 아닌 경우]
OrderService가 EJB 기술을 직접 사용
→ EJB가 deprecated 되면 OrderService 코드 전체 수정
→ 수십 개 클래스가 EJB를 쓰고 있으면 전부 수정

[POJO인 경우]
OrderService는 순수 Java만 사용
→ 기술이 바뀌어도 OrderService는 그대로
→ 설정만 바꾸면 됨
```

**정리**: POJO는 **특정 기술에 묶이지 않아서**, 기술이 바뀌어도 **코드를 덜 고치고**, **테스트·디버깅이 쉬워진다.**

---

### 2.2 IoC (Inversion of Control, 제어의 역전)

#### 기존 방식: 개발자가 모든 걸 제어

```java
// 개발자가 직접 객체를 생성하고 연결함
class OrderService {
    private PaymentService payment = new KakaoPayment();  // 직접 new!
    
    void order() {
        payment.pay();  // KakaoPayment에 강하게 묶여 있음
    }
}
```

- `OrderService`가 `KakaoPayment`를 **직접** 만들고 있음
- 나중에 `TossPayment`로 바꾸려면? → `OrderService` 코드를 수정해야 함
- **제어권이 개발자(클래스)에게 있음**

#### IoC: 제어권이 스프링(프레임워크)으로 넘어감

```java
// 스프링이 객체를 만들어서 넣어줌
class OrderService {
    private PaymentService payment;  // 직접 new 안 함!
    
    public OrderService(PaymentService payment) {
        this.payment = payment;  // 외부에서 받아옴
    }
    
    void order() {
        payment.pay();
    }
}
```

- `OrderService`는 "`PaymentService` 타입의 뭔가"만 알면 됨
- **누가, 어떤 구현체(KakaoPayment, TossPayment)를 넣어줄지는 스프링이 결정**
- 결제사만 바꾸고 싶다면 → 설정만 바꾸면 됨, `OrderService` 코드는 그대로

**정리**: IoC = **객체 생성·연결의 제어권**이 **개발자 → 스프링(컨테이너)**로 넘어가는 것

---

### 2.3 DI (Dependency Injection, 의존성 주입)

#### 의존성이란?

A가 B의 메서드를 호출하면 → **A는 B에 의존한다**고 한다.

```java
class A {
    void doSomething() {
        B b = new B();
        b.help();  // A가 B에 의존
    }
}
```

#### 의존성 주입이란?

**의존하는 객체(B)를, A가 직접 만들지 않고, 밖에서 만들어서 넣어준다**는 뜻이다.

```java
// 생성자 주입 (가장 권장)
class A {
    private B b;
    
    public A(B b) {
        this.b = b;  // 외부에서 B를 받아서 저장
    }
    
    void doSomething() {
        b.help();
    }
}
```

- A는 B를 **직접 생성하지 않음**
- 스프링이 B 인스턴스를 만들고, A의 생성자에 **주입**해줌

#### DI의 장점

| 장점 | 설명 |
|------|------|
| **느슨한 결합** | A가 B 구현체에 묶이지 않음. B를 바꿔도 A 코드 수정 불필요 |
| **테스트 용이** | 테스트할 때 가짜 B(Mock)를 넣어주기 쉬움 |
| **유연한 변경** | 설정만 바꿔서 다른 구현체로 교체 가능 |

---

### 2.4 AOP (Aspect Oriented Programming, 관점 지향 프로그래밍)

#### 문제 상황

주문, 결제, 회원가입, 상품등록... 모든 기능에 **로깅**, **보안 체크**, **트랜잭션**이 필요하다.

```java
void 주문하기() {
    log("시작");           // 공통
    보안체크();             // 공통
    트랜잭션시작();         // 공통
    // 실제 주문 로직      ← 핵심
    트랜잭션커밋();         // 공통
    log("종료");           // 공통
}

void 결제하기() {
    log("시작");           // 또 반복...
    보안체크();             // 또 반복...
    트랜잭션시작();         // 또 반복...
    // 실제 결제 로직      ← 핵심
    ...
}
```

- **공통 코드가 모든 메서드에 반복**됨
- 로깅 방식이 바뀌면 → 모든 메서드를 찾아서 수정해야 함

#### AOP의 해결 방식

**공통 관심 사항**(로깅, 보안, 트랜잭션)을 **별도 모듈(Aspect)**로 분리하고,  
필요한 시점에 **자동으로 끼워 넣는** 방식이다.

```
[분리 전]
주문하기() { 로깅 + 보안 + 트랜잭션 + 주문로직 }
결제하기() { 로깅 + 보안 + 트랜잭션 + 결제로직 }
회원가입() { 로깅 + 보안 + 트랜잭션 + 가입로직 }

[분리 후 - AOP]
주문하기() { 주문로직 }     ← 핵심만
결제하기() { 결제로직 }     ← 핵심만
회원가입() { 가입로직 }     ← 핵심만

+ [공통 모듈] 로깅, 보안, 트랜잭션 → 스프링이 알아서 필요한 곳에 적용
```

**정리**: AOP = **여러 곳에 반복되는 공통 기능**을 **한 곳에서 관리**하게 해주는 것

---

### 2.5 PSA (Portable Service Abstraction, 일관된 서비스 추상화)

#### 문제 상황

- MySQL, Oracle, MariaDB, MongoDB... DB마다 사용 방법이 다름
- MySQL로 개발했다가 MariaDB로 바꾸면? → DB 접근 코드를 상당 부분 다시 짜야 함

#### PSA의 해결 방식

스프링이 **공통 인터페이스(추상화)**를 제공해서, **같은 방식으로** 여러 기술을 쓰게 해준다.

```
[PSA 없이]
MySQL 코드 ≠ Oracle 코드 ≠ MariaDB 코드  → DB 바꿀 때마다 코드 수정

[PSA 적용 - 예: JDBC, JPA]
공통 인터페이스로 작성 → DB만 바꿔도 기존 코드 그대로 사용 가능
```

- **JDBC**: DB 접근을 추상화 → DB 벤더가 바뀌어도 코드 유지
- **Spring Data JPA**: JPA를 한 번 더 추상화 → 구현체(Hibernate 등) 교체 용이

**정리**: PSA = **기술을 추상화**해서, **바꿔도 코드를 최대한 그대로** 쓸 수 있게 해주는 것

---

## 3. 스프링 컨테이너

### 3.1 컨테이너란?

**객체(Bean)를 만들고, 관리하고, 필요할 때 꺼내 쓰게 해주는 "공장"**이라고 생각하면 된다.

- **Bean Factory** / **IoC Container**라고도 부름
- 스프링이 객체의 **생성 → 의존성 주입 → 생명주기**를 관리함

### 3.2 왜 필요한가?

- 개발자가 **`new`**로 객체를 만들지 않아도 됨
- **의존 관계**를 스프링이 설정에 따라 **자동으로 연결**해 줌
- **싱글톤** 등 객체 생명주기도 컨테이너가 관리

### 3.3 핵심 정리

> **스프링의 핵심 = 기술 비침투 + IoC/DI + POJO**  
> 비즈니스 로직에만 집중하고, 객체 생성·연결·공통 기능은 스프링이 담당한다.

---

## 4. 스프링 프레임워크 모듈 구조

스프링은 **필요한 것만 골라 쓸 수 있는 모듈형** 구조다.

| 모듈 | 역할 |
|------|------|
| **Spring Core** | IoC 컨테이너, Bean 관리, DI |
| **Spring AOP** | 관점 지향 프로그래밍 |
| **Spring Web MVC** | 웹 애플리케이션, MVC 패턴 |
| **Spring Data** | DB 접근 단순화 (JPA, JDBC 등) |
| **Spring Security** | 인증, 권한, 보안 |
| **Spring Batch** | 대량 데이터 처리 |

---

## 5. 스프링부트(Spring Boot)란?

### 5.1 스프링의 불편한 점

스프링만 쓰면 **초기 설정이 많고 복잡**하다. **XML**, **Java 설정**, **의존성 버전 맞추기** 등...

### 5.2 스프링 부트의 역할

**스프링으로 개발할 때 필요한 설정을 최대한 자동으로 해주는 도구**

| 기능 | 설명 |
|------|------|
| **자동 설정** | 필요한 라이브러리·설정을 자동으로 적용 |
| **내장 웹 서버** | Tomcat 등이 포함되어 있어 별도 WAS 설치 불필요 |
| **독립 실행 Jar** | `java -jar app.jar` 한 줄로 실행 가능 |
| **Starter 의존성** | `spring-boot-starter-web` 하나로 웹 개발에 필요한 것 한 번에 추가 |

### 5.3 스프링 vs 스프링 부트

| 구분 | 스프링 | 스프링 부트 |
|------|--------|-------------|
| 설정 | 직접 많이 해야 함 | 자동 설정 위주 |
| 배포 | War + 외부 WAS | 내장 서버 + Jar |
| 시작 난이도 | 상대적으로 높음 | 상대적으로 낮음 |

---

## 6. 스프링부트 시작하기

### 6.1 사전 조건

1. **JDK** 설치 (Java 17 권장)
2. **JAVA_HOME** 환경 변수 설정
3. **IDE** (IntelliJ, Eclipse 등)

### 6.2 Spring Initializr로 프로젝트 생성

1. [start.spring.io](https://start.spring.io/) 접속
2. **Project**: Maven 또는 Gradle
3. **Language**: Java
4. **Spring Boot**: 최신 안정 버전 (SNAPSHOT 제외)
5. **Project Metadata**: Group, Artifact, Name 등 입력
6. **Dependencies**: `Spring Web` 추가
7. **GENERATE** 클릭 → zip 다운로드
8. 압축 해제 후 IDE에서 열기
9. `main()` 메서드 실행 → `Started xxxApplication in x.xxx seconds` 확인

### 6.3 실행 확인

콘솔에 **`Started xxxApplication`**이 보이고, 실행 아이콘이 계속 돌고 있으면  
**내장 웹 서버(WAS)가 정상적으로 떠 있는 상태**다.

---

## 7. 한눈에 보는 정리

| 개념 | 한 줄 요약 |
|------|------------|
| **스프링** | 기업용 Java 웹 개발을 쉽게 해주는 오픈소스 프레임워크 |
| **EJB → 스프링** | 기술 침투·복잡함을 줄이려고 탄생 |
| **POJO** | 순수 Java 객체, 특정 기술에 묶이지 않음 |
| **IoC** | 객체 생성·연결을 스프링이 담당 (제어권 역전) |
| **DI** | 의존 객체를 외부에서 주입받음 |
| **AOP** | 로깅·보안 등 공통 기능을 분리해서 관리 |
| **PSA** | 기술을 추상화해서 교체해도 코드 유지 |
| **스프링 컨테이너** | Bean을 생성·관리하는 IoC 컨테이너 |
| **스프링 부트** | 스프링 초기 설정을 자동화해주는 도구 |
